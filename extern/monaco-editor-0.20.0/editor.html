<!DOCTYPE html>
<!-- This file will be copied to the host/components/monaco after build so that any changes made will be reflected in that build-->
<html>

<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="./min/vs/editor/editor.main.css" />
</head>

<body>
    <div id="container" style="width: 100%; height: 300px;"></div>
    <!-- 
            the "loader.js" adds the editor and initializes the require variable
            the "editor.main.js" inits and defines the MonacoEditor
            the "editor.main.nls.js" defines the key bindings and definitions of the Monaco Editor
        -->

    <script>
        var require = { paths: { vs: './min/vs' } };
    </script>
    <script src="./min/vs/loader.js"></script>
    <script src="./min/vs/editor/editor.main.nls.js"></script>
    <script src="./min/vs/editor/editor.main.js"></script>
    <script type="text/javascript" src="qrc:///qtwebchannel/qwebchannel.js"></script>
    <script src="./qtQuick.js" type="text/javascript"></script>
    <script type="text/javascript">
        new QWebChannel(qt.webChannelTransport, function (channel) {
            // all published objects are available in channel.objects under
            // the identifier set in their attached WebChannel.id property
            var link = channel.objects.valueLink;

            link.setValue.connect(function (value) {
                editor.setValue(value);
            });

            link.setContainerHeight.connect(function (height) {
                document.getElementById("container").setAttribute("style", `height:${height}px`);
                editor.layout()
            });

            link.setContainerWidth.connect(function (width) {
                document.getElementById("container").setAttribute("style", `width:${width}px`);
                editor.layout()
            });

            link.undo.connect(function () {
                editor.trigger('undoClicked', 'undo');
            });

            link.redo.connect(function () {
                editor.trigger('redoClicked', 'redo');
            });

            editor.getModel().onDidChangeContent((event) => {
                link.fileText = editor.getValue();
                link.setVersionId(editor.getModel().getAlternativeVersionId());
            });
        });
    </script>

    <script>
        monaco.languages.register({ id: 'qml' })
        monaco.languages.setMonarchTokensProvider('qml', {
            keywords: ['readonly', 'property', 'for', 'if', 'else', 'do', 'while', 'true', 'false', 'signal', 'const', 'switch', 'import', 'as', "on", 'async', 'console', "let", "default", "function"],
            typeKeywords: ['int', 'real', 'var', 'string', 'color', 'url', 'alias', 'bool'],
            operators: [
                '=', '>', '<', '!', '~', '?', ':', '==', '<=', '>=', '!=', '===', '<==', '>==', '!==',
                '&&', '||', '++', '--', '+', '-', '*', '/', '&', '|', '^', '%',
                '<<', '>>', '>>>', '+=', '-=', '*=', '/=', '&=', '|=', '^=',
                '%=', '<<=', '>>=', '>>>='
            ],
            digits: /\d+(_+\d+)*/,
            symbols: /[=><!~?:&|+\-*\/\^%]+/,
            escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,
            regexpctl: /[(){}\[\]\$\^|\-*+?\.]/,
            regexpesc: /\\(?:[bBdDfnrstvwWn0\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})/,
            tokenizer: {
                root: [
                    [/[{}]/, 'delimiter.bracket'],
                    [/[a-z_$][\w$]*/, {
                        cases: {
                            '@typeKeywords': 'keyword',
                            '@keywords': 'keyword',

                        }
                    }
                    ],
                    [/[A-Z][\w\$]*/, 'type.identifier'],
                    [/(?:^|\{|;)\s*[a-z][\w\.]*\s*(?=\:|\{)/, "property.defs"],
                    { include: '@whitespace' },
                    [/\/(?=([^\\\/]|\\.)+\/([gimsuy]*)(\s*)(\.|;|\/|,|\)|\]|\}|$))/, { token: 'regexp', bracket: '@open', next: '@regexp' }],
                    [/[()\[\]]/, '@brackets'],
                    [/[<>](?!@symbols)/, '@brackets'],
                    [/@symbols/, {
                        cases: {
                            '@operators': 'delimiter',
                            '@default': ''
                        }
                    }
                    ],
                    [/(@digits)[eE]([\-+]?(@digits))?/, 'number.float'],
                    [/(@digits)\.(@digits)([eE][\-+]?(@digits))?/, 'number.float'],
                    [/(@digits)/, 'number'],
                    [/[;,.]/, 'delimiter'],
                    [/"([^"\\]|\\.)*$/, 'string.invalid'],  // non-teminated string
                    [/'([^'\\]|\\.)*$/, 'string.invalid'],  // non-teminated string
                    [/"/, 'string', '@string_double'],
                    [/'/, 'string', '@string_single'],
                    [/`/, 'string', '@string_backtick'],

                ],
                whitespace: [
                    [/[ \t\r\n]+/, ''],
                    [/\/\*\*(?!\/)/, 'comment.doc', '@jsdoc'],
                    [/\/\*/, 'comment', '@comment'],
                    [/\/\/.*$/, 'comment'],
                ],

                comment: [
                    [/[^\/*]+/, 'comment'],
                    [/\*\//, 'comment', '@pop'],
                    [/[\/*]/, 'comment']
                ],

                jsdoc: [
                    [/[^\/*]+/, 'comment.doc'],
                    [/\*\//, 'comment.doc', '@pop'],
                    [/[\/*]/, 'comment.doc']
                ],

                // We match regular expression quite precisely
                regexp: [
                    [/(\{)(\d+(?:,\d*)?)(\})/, ['regexp.escape.control', 'regexp.escape.control', 'regexp.escape.control']],
                    [/(\[)(\^?)(?=(?:[^\]\\\/]|\\.)+)/, ['regexp.escape.control', { token: 'regexp.escape.control', next: '@regexrange' }]],
                    [/(\()(\?:|\?=|\?!)/, ['regexp.escape.control', 'regexp.escape.control']],
                    [/[()]/, 'regexp.escape.control'],
                    [/@regexpctl/, 'regexp.escape.control'],
                    [/[^\\\/]/, 'regexp'],
                    [/@regexpesc/, 'regexp.escape'],
                    [/\\\./, 'regexp.invalid'],
                    [/(\/)([gimsuy]*)/, [{ token: 'regexp', bracket: '@close', next: '@pop' }, 'keyword.other']],
                ],

                regexrange: [
                    [/-/, 'regexp.escape.control'],
                    [/\^/, 'regexp.invalid'],
                    [/@regexpesc/, 'regexp.escape'],
                    [/[^\]]/, 'regexp'],
                    [/\]/, { token: 'regexp.escape.control', next: '@pop', bracket: '@close' }],
                ],

                string_double: [
                    [/[^\\"]+/, 'string'],
                    [/@escapes/, 'string.escape'],
                    [/\\./, 'string.escape.invalid'],
                    [/"/, 'string', '@pop']
                ],

                string_single: [
                    [/[^\\']+/, 'string'],
                    [/@escapes/, 'string.escape'],
                    [/\\./, 'string.escape.invalid'],
                    [/'/, 'string', '@pop']
                ],

                string_backtick: [
                    [/\$\{/, { token: 'delimiter.bracket' }],
                    [/[^\\`$]+/, 'string'],
                    [/@escapes/, 'string.escape'],
                    [/\\./, 'string.escape.invalid'],
                    [/`/, 'string', '@pop']
                ],
            }

        })
        monaco.editor.defineTheme('qmlTheme', {
            base: 'vs',
            inherit: false,
            rules: [
                { token: "comment", foreground: "#32C132" },
                { token: "delimiter.bracket", foreground: "#000000" },
                { token: "keyword", foreground: "#C6CC18" },
                { token: "type.identifier", foreground: "#DF00FF" },
                { token: "string", foreground: "#32C132" },
                { token: "property.defs", foreground: "#BA262B" },
            ]
        })

        monaco.languages.registerCompletionItemProvider('qml', {
            provideCompletionItems: (model, position) => {
                var textUntilPosition = model.getValueInRange({ startLineNumber: 1, startColumn: 1, endLineNumber: position.lineNumber, endColumn: position.column });
                var word = model.getWordUntilPosition(position);
                var range = {
                    startLineNumber: position.lineNumber,
                    endLineNumber: position.lineNumber,
                    startColumn: word.startColumn,
                    endColumn: word.endColumn
                };
                var sgwidgetsFlag = textUntilPosition.match(`import tech.strata.sgwidgets 1.0`);
                var qtQuickFlag = textUntilPosition.match(`import QtQuick`)
                initializeQtQuick({ qtQuickFlag: qtQuickFlag, sgwidgetsFlag: sgwidgetsFlag })
                var suggestions = []
                clearPropertySuggestions()
                for (const [key] of Object.entries(qtObjectKeyValues)) {
                    suggestions.push({
                        label: qtObjectKeyValues[key].label,
                        kind: monaco.languages.CompletionItemKind.Property,
                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                        insertText: qtObjectKeyValues[key].insertText,
                        range: range
                    })
                    convertStrArrayToObjArray(qtObjectKeyValues[key].properties, range)
                }
                suggestions = suggestions.concat(propertySuggestions)
                return { suggestions: suggestions }

            }
        })

        var editor = monaco.editor.create(document.getElementById('container'), {
            value: "",
            language: 'qml',
            theme: "qmlTheme",
            insertSpaces: true,
            detectIndentation: true,
            tabCompletion: "on",
            formatOnPaste: true,

        });

        function getValue() {
            return editor.getValue();
        }

        function setValue(value) {
            editor.setValue(value)
        }

    </script>
</body>

</html>